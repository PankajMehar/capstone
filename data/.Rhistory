return (results)
}
#theta: value of theta to calculate posterior probability for
posterior.prob <- function(theta) {
result=((theta-5)/2)^2
result=result/3
result=result+1
result=(result)^-2
return (result)
}
#Init: Starting value for theta
#var: Variance of the proposal distribution
#iter: Number of iterations
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
}
results = data.frame(theta=thetas,accept=accepts)
return (results)
}
init=1
var=4
iter=1000
results = mrw(init,var,iter,FUN=posterior.prob)
results
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
results = data.frame(theta=thetas,accept=accepts,iteration=c(iterations))
return (results)
}
init=1
var=4
iter=1000
results = mrw(init,var,iter,FUN=posterior.prob)
results
head(results)
results
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
library('ggplot2')
#iter: Number of iterations
#Execute metropolis random walk for some number of iterations
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
results = data.frame(theta=thetas,accept=accepts,iteration=c(iterations))
return (results)
}
library('ggplot2')
init=1
var=4
iter=1000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=10000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=100000
results = mrw(init,var,iter,FUN=posterior.prob)
init=1
var=4
iter=20000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=30000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=79
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=5
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
posterior.prob(1)
posterior.prob(2)
init=5
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
posterior.
library('ggplot2')
#Calculate posterior probability to some constant of proportionality for some value of theta
posterior.prob <- function(theta) {
result=((theta-5)/2)^2
result=result/3
result=result+1
result=(result)^-2
return (result)
}
#Init: Starting value for theta
#var: Variance of the proposal distribution
#iter: Number of iterations
#Execute metropolis random walk for some number of iterations
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
results = data.frame(theta=thetas,accept=accepts,iteration=c(iterations))
return (results)
}
init=5
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
results = data.frame(theta=thetas,accept=accepts,iteration=iterations)
return (results)
}
init=5
var=40
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=5
var=5
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
thetas
iterations
acceps
accepts
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
print(length(thetas))
print(length(accepts))
print(length(iterations))
results = data.frame(theta=thetas,accept=accepts,iteration=iterations)
return (results)
}
init=5
var=5
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
print(length(thetas))
iterations = c(iterations,i)
}
print(length(thetas))
print(length(accepts))
print(length(iterations))
results = data.frame(theta=thetas,accept=accepts,iteration=iterations)
return (results)
}
init=5
var=5
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
theta = init
theta
#var: Variance of the proposal distribution
#iter: Number of iterations
#Execute metropolis random walk for some number of iterations
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(init,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
print(theta)
iterations = c(iterations,i)
}
print(length(thetas))
print(length(accepts))
print(length(iterations))
results = data.frame(theta=thetas,accept=accepts,iteration=iterations)
return (results)
}
init=5
var=5
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
?rnorm
mrw <- function(init,var,iter,FUN=posterior.prob) {
thetas = c(init)
accepts = c(NA)
iterations = c(0)
theta = init
for (i in 1:iter) {
#Generate proposal
proposal = rnorm(1,theta,var)
#Generate posterior probs
post.current = FUN(theta)
post.proposal = FUN(proposal)
alpha = min(1,post.proposal/post.current)
if (alpha==1) {
theta = proposal
accepts = c(accepts,1)
}
else {
samp = runif(1,0,1)
if (samp<=alpha) {
theta = proposal
accepts=c(accepts,1)
}
else {
accepts = c(accepts,0)
}
}
thetas = c(thetas,theta)
iterations = c(iterations,i)
}
results = data.frame(theta=thetas,accept=accepts,iteration=iterations)
return (results)
}
init=5
var=5
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=5000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=10000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=20000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=4
iter=30000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=2
iter=30000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=2
iter=50000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
init=1
var=2
iter=75000
results = mrw(init,var,iter,FUN=posterior.prob)
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()
ggplot(data=results,aes(x=iteration,y=theta))+geom_line()+ggtitle("Trace Plot for Metropolis Algorithm")
results.slim = results[40000:,]
results[40000:]
results[40000:75000,]
results[40000:end,]
results.slim = results[40000:75000,]
dim(results.slim)
sum(results.slim$accept)/length(results.slim$accept)
acceptRaterAfterBurn = sum(results.slim$accept)/length(results.slim$accept)
acceptRaterAfterBurn
tracePlot=ggplot(data=results,aes(x=iteration,y=theta))+geom_line()+ggtitle("Trace Plot for Metropolis Algorithm")
tracePlot #Created above
results2= mrw(init,var,90000,FUN=posterior.prob)
ggplot(data=results2,aes(x=iteration,y=theta))+geom_line()+ggtitle("Trace Plot for Metropolis Algorithm")
mean=mean(results.slim$theta)
var=var(results.slim$theta)
mean
var
sum(results.slim$theta>7)/length(results.slim$theta)
hist(results.slim$theta)
head(RiskClaimByDriver)
setwd("~/Desktop")
setwd("~/Desktop/Capstone/data")
Risk = dbGetQuery(con,'select * FROM RISK')
library("RSQLite")
Risk = dbGetQuery(con,'select * FROM RISK')
sqlite = dbDriver("SQLite")
con = dbConnect(sqlite,dbname="../CapstoneV1.db")
Risk = dbGetQuery(con,'select * FROM RISK')
Risk = dbGetQuery(con,'select * FROM RISK')
Risk = dbGetQuery(con,'select * FROM Risk')
Risk = dbGetQuery(con,'SELECT * FROM RISK')
sqlite = dbDriver("SQLite")
con = dbConnect(sqlite,dbname="CapstoneV1.db")
Risk = dbGetQuery(con,'SELECT * FROM RISK')
length(unique(Risk$DriverID))
dim(Risk)
RiskClaimByDriver = dbGetQuery(con,'select RISK.id,RISK.PolicyID,RISK.DriverID,RISK.VehicleID,RISK.LocationID,AVG(RISK.Premium) as Premium,SUM(CLAIM.Amount) as Amount FROM RISK LEFT JOIN CLAIM on RISK.DriverID=CLAIM.DriverID Group by RISK.DriverID')
RiskClaimByDriver$Amount[which(is.na(RiskClaimByDriver$Amount))] = 0
RiskClaimByDriver$Amount = as.numeric(RiskClaimByDriver$Amount)
RiskClaimByDriver$LossRatio = RiskClaimByDriver$Amount/RiskClaimByDriver$Premium
RiskClaimByDriver$gain = RiskClaimByDriver$Premium-RiskClaimByDriver$Amount
Driver = dbGetQuery(con,'select * FROM DRIVER')
#Combine RiskClaimByDriver with Driver
BottomLineDriver = merge(RiskClaimByDriver,Driver,by.x=c('DriverID'),by.y=c('id'))
head(BottomLineDriver)
